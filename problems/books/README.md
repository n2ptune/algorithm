# 이것이 취업을 위한 코딩테스트다 With 파이썬

책에 나오는 기출문제를 풀고 어떻게 풀었는지 나중에 복습하기 위해 그리고 푼 문제를 한번 더 보고 더 좋은 방법을 찾기 위해 기록합니다. 아래 문제들의 해설은 전부 주관적이며 정답 페이지를 보고 적은 해설이 아니기 때문에 정확하지 않을 수 있습니다.

## 목차

- [그리디 문제 01 모험가 길드](./greedy-01.md)
- [그리디 문제 02 곱하기 혹은 더하기](./greedy-02.md)

## 문제 풀이

각 문제들을 어떻게 풀었는지를 작성합니다.

### 그리디

> 현재 상황에서 가장 좋아 보이는 것만을 선택하는 알고리즘입니다. 현재 상황에서 가장 좋아 보이는 것만을 선택하기 때문에, 정확한 답을 도출하지 못하더라도 그럴싸한 답을 도출하는 데에 도움이 됩니다. 하지만 코딩 테스트에서는 대부분 '최적의 해'를 찾는 문제가 출제되기 때문에 그리디 알고리즘의 정당성을 고민하면서 문제 해결 방안을 떠올려야 합니다.

#### 모험가 길드

모험가의 정보를 모두 입력받고 오름차순으로 정렬합니다. 먼저 정렬하게 되면 최소한의 그룹 인원으로 그룹을 구성할 수 있으며 문제에서 요구하는 최대 그룹 수를 구할 수 있습니다. 그룹 수를 카운트하기 위해 `group_count` 변수와 현재 그룹의 명 수를 담기위해 변수 `group`을 선언하고 0으로 초기화합니다.

모든 모험가를 반복하고 `group`에 1씩 더합니다. 만약 현재 모험가의 공포도가 그룹 수와 동일하다면 그룹이 결성됬으므로 `group_count`를 하나 늘리고 `group`을 다시 0으로 초기화합니다.

```python
N = int(input())
people = list(map(int, input().split()))
people.sort()
group_count = 0
group = 0

for p in people:
  group += 1

  if group >= p:
    group_count += 1
    group = 0

print(group_count)
```

#### 곱하기 혹은 더하기

제일 먼저 생각해야될 건 규칙성일 것 같습니다. 연산을 시도하려는 두 수 중 하나라도 0을 포함한다면 다른 수가 아무리 큰 수라도 곱해버리면 0이 되니 더해야합니다. 그리고 두 수 중 하나라도 1이라면 곱하기는 항상 제자리이기 때문에 더해야 제일 큰 수를 얻을 수 있습니다. 이 규칙을 제외하고는 모두 곱합니다. 그리고 이 문제에서는 사칙연산의 우선순위는 무시하고 왼쪽부터 순서대로 연산하므로 왼쪽부터 반복하면 됩니다.

길이가 1일 땐 더하거나 곱할 수가 없으므로 그 수가 제일 큰 수입니다. 길이가 2일 땐 두 수를 곱하거나 더한 수가 제일 큰 수입니다. 두 수가 들어오면 이걸 더할지, 곱할지 판단해주는 함수를 하나 만들고 제일 큰 수를 반환하게 합니다.

길이가 3 이상인 리스트에서는 먼저 첫번째 인덱스와 두번째 인덱스를 계산하고 저장해둡니다. 그리고 나머지 수들과 저장해둔 수와 더하거나 곱합니다. 이 행위를 리스트 끝까지 반복합니다.

```py
S = list(map(int, list(input())))


def calTwoNum(a, b):
  if a == 0 or b == 0:
    return a + b
  elif a == 1 or b == 1:
    return a + b
  else:
    return a * b


if len(S) == 1:
  print(S[0])
elif len(S) == 2:
  print(calTwoNum(S[0], S[1]))
else:
  C = calTwoNum(S[0], S[1])
  S = S[2:]

  for num in S:
    C = calTwoNum(C, num)

  print(C)
```
